<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<title>Flying Car Game - Hogwarts Flight</title>
<style>
  body {
    margin: 0;
    overflow: hidden;
    background: #9dd9ff;
  }
  #gameCanvas {
    display: block;
    margin: auto;
    background: #87ceeb;
  }
  #clue {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(255,255,255,0.9);
    padding: 20px 30px;
    border-radius: 15px;
    box-shadow: 0 0 10px rgba(0,0,0,0.3);
    font-size: 1.2em;
    text-align: center;
    display: none;
  }
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<div id="clue">üïµÔ∏è‚Äç‚ôÇÔ∏è Cestitke!!.</div>
<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

const carImg = new Image();
carImg.src = "car.png";

// --- Game state ---
let carY, velocity, obstacles, frame, gameOver, started;
const gravity = 0.4;
const jump = -7;
let backgroundOffset = 0;
let timeOfDay = 0; // 0 = day, 1 = night
let distance = 0;
let scaleFactor = 1; // will calculate on resize

// --- Background offscreen canvas ---
const bgWidth = 1920;
const bgHeight = 640;
const bgCanvas = document.createElement("canvas");
bgCanvas.width = bgWidth;
bgCanvas.height = bgHeight;
const bgCtx = bgCanvas.getContext("2d");

// --- Static starfield (generated once) ---
const stars = [];
for (let i = 0; i < 80; i++) {
  stars.push({
    x: Math.random() * 1920,       // use bgWidth here for consistency
    y: Math.random() * 320,        // upper half of screen
    size: Math.random() * 2 + 1,   // slight size variety
  });
}


// --- Build static background ---
function buildBackground() {
    
    // Hills
    const hillColors = ["#4caf50","#66bb6a","#81c784"];
    hillColors.forEach((color,i) => {
        const amplitude = 40 + i*25;
        const offsetY = 100 - i*20;
        bgCtx.fillStyle = color;
        bgCtx.beginPath();
        bgCtx.moveTo(0,bgHeight);
        for(let x=0;x<=bgWidth;x+=20){
            const y = bgHeight - (amplitude * Math.sin((x + i*100)*0.004)) - offsetY;
            bgCtx.lineTo(x,y);
        }
        bgCtx.lineTo(bgWidth,bgHeight);
        bgCtx.closePath();
        bgCtx.fill();
    });

    // Clouds
    bgCtx.fillStyle="white";
    for(let i=0;i<20;i++){
        const x = Math.random()*bgWidth;
        const y = Math.random()*200+50;
        const size = Math.random()*40+20;
        bgCtx.beginPath();
        bgCtx.arc(x,y,size,0,Math.PI*2);
        bgCtx.arc(x+size*0.8,y+10,size*0.8,0,Math.PI*2);
        bgCtx.arc(x-size*0.8,y+10,size*0.8,0,Math.PI*2);
        bgCtx.fill();
    }
}

// --- Draw background with day-to-night transition ---
function drawBackground(speed = 0) {
  backgroundOffset += speed;
  const offsetX = backgroundOffset % bgWidth;

  // Day‚Üínight progression
  timeOfDay = Math.min(1, Math.max(0, (distance - 10000) / 24000));

  // Draw sky directly (no gradient needed, just lerp color day‚Üínight)
  const currentSky = lerpColor("#87ceeb","#00143d", timeOfDay); // lighter‚Üídarker
  ctx.fillStyle = currentSky;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Draw static hills and clouds from bgCanvas
  ctx.drawImage(bgCanvas, -offsetX, 0, bgWidth * scaleFactor, bgHeight * scaleFactor);
  ctx.drawImage(bgCanvas, bgWidth - offsetX, 0, bgWidth * scaleFactor, bgHeight * scaleFactor);

  // Night overlay (optional, keep for stars and subtle darkness)
  const nightOverlay = `rgba(0, 20, 60, ${timeOfDay * 0.4})`;
  ctx.fillStyle = nightOverlay;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Stars (keep as before)
  if (timeOfDay > 0.4) {
    const starAlpha = (timeOfDay - 0.4) * 1.5;
    ctx.fillStyle = `rgba(255, 255, 255, ${0.4 * Math.min(starAlpha, 1)})`;
    for (const s of stars) {
      const x = (s.x * scaleFactor - offsetX + bgWidth * scaleFactor) % (bgWidth * scaleFactor);
      const y = s.y * scaleFactor;
      ctx.beginPath();
      ctx.arc(x, y, s.size * scaleFactor, 0, Math.PI * 2);
      ctx.fill();
    }
  }
}

// --- Obstacles ---
const baseGapY = 250;
const horizontalSpacing = 300;
const offsets = [];
const segments = [
    [-80,-50,-30,-60,-40],
    [60,80,70,90],
    [-100,-90,-70],
    [0,100,-80,50],
    [40,-60,20,-50,30]
];
while(offsets.length < 100) segments.forEach(s=>offsets.push(...s));
offsets.length = 100;
const track = offsets.map((o,i)=>({x:600+i*horizontalSpacing,gapY:baseGapY+o}));

// --- Utilities ---
function lerpColor(a,b,t){
    const ah=parseInt(a.replace('#',''),16),ar=(ah>>16)&0xff,ag=(ah>>8)&0xff,ab=ah&0xff;
    const bh=parseInt(b.replace('#',''),16),br=(bh>>16)&0xff,bg=(bh>>8)&0xff,bb=bh&0xff;
    const rr=Math.round(ar+(br-ar)*t),rg=Math.round(ag+(bg-ag)*t),rb=Math.round(ab+(bb-ab)*t);
    return `rgb(${rr},${rg},${rb})`;
}

// --- Draw car ---
function drawCar(){
    const scale = 0.12 * scaleFactor;
    const w = carImg.width * scale;
    const h = carImg.height * scale;
    const tilt = velocity * 2 * Math.PI / 180;
    ctx.save();
    ctx.translate(100*scaleFactor, carY);
    ctx.rotate(tilt);
    ctx.drawImage(carImg,-w/2,-h/2,w,h);
    ctx.restore();
}

// --- Draw obstacles ---
function drawObstacles(){
    const obsW = 60 * scaleFactor;
    const obsGap = 100 * scaleFactor;
    for(const o of obstacles){
        ctx.fillStyle="rgba(240,108,0,0.6)";
        ctx.strokeStyle="black";
        ctx.lineWidth=2*scaleFactor;

        // top
        ctx.beginPath();
        ctx.rect(o.x,0,obsW,o.gapY-obsGap);
        ctx.fill(); ctx.stroke();

        // bottom
        ctx.beginPath();
        ctx.rect(o.x,o.gapY+obsGap,obsW,canvas.height-o.gapY);
        ctx.fill(); ctx.stroke();
    }
}

// --- Game loop ---
function update(){
    if(gameOver) return;
    frame++;
    velocity += gravity;
    carY += velocity;

    const speed = 3 + frame/800;
    obstacles.forEach(o=>o.x-=speed*scaleFactor);

    drawBackground(speed*scaleFactor);
    drawObstacles();
    drawCar();

    distance += speed;

    // --- Draw obstacle counter (mobile-friendly) ---
const obstaclesLeft = obstacles.filter(o => o.x > -60 * scaleFactor).length;

// Position slightly below top for visibility
const counterY = 80 * scaleFactor;
const counterX = canvas.width / 2;

// Set font scaled
ctx.font = `bold ${40 * scaleFactor}px sans-serif`;
ctx.textAlign = "center";
ctx.textBaseline = "top"; // ensures Y starts from top

// Draw white border
ctx.lineWidth = 4 * scaleFactor;
ctx.strokeStyle = "white";
ctx.strokeText(obstaclesLeft, counterX, counterY);

// Fill with black
ctx.fillStyle = "black";
ctx.fillText(obstaclesLeft, counterX, counterY);




    // collisions
    const obsW = 60*scaleFactor;
    const obsGap = 100*scaleFactor;
    for(const o of obstacles){
        if(100*scaleFactor+25*scaleFactor > o.x && 100*scaleFactor-25*scaleFactor < o.x+obsW
            && (carY-10*scaleFactor<o.gapY-obsGap || carY+10*scaleFactor>o.gapY+obsGap)){
            return endGame(false);
        }
    }
    if(carY<0 || carY>canvas.height) return endGame(false);
    if(obstacles.every(o=>o.x<-obsW)) return endGame(true);

    requestAnimationFrame(update);
}

// --- Reset game ---
const startText = {
    title:"üßô HP 3: The Chamber ü™Ñ",
    subtitle:"GCBF1BN, by Enra13 & Ammy Holmes",
    description:"Press SPACE or tap to start your flight to Hogwarts!"
};


function resetGame() {
  // Reset transform so we draw in correct coordinate space
  ctx.setTransform(1, 0, 0, 1, 0, 0);
  ctx.scale(window.devicePixelRatio || 1, window.devicePixelRatio || 1);

  carY = canvas.height / 2 / (window.devicePixelRatio || 1);
  velocity = 0;
  frame = 0;
  backgroundOffset = 0;
  gameOver = false;
  started = false;
  obstacles = track.map(o => ({ ...o }));
  distance = 0;

  // Clear screen
  ctx.fillStyle = "#87ceeb";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Draw visible title text
  ctx.fillStyle = "white";
  ctx.textAlign = "center";

  ctx.font = `bold ${36 * scaleFactor}px sans-serif`;
  ctx.fillText(startText.title, canvas.width / 2 / (window.devicePixelRatio || 1), canvas.height / 2 / (window.devicePixelRatio || 1) - 40 * scaleFactor);

  ctx.font = `${24 * scaleFactor}px sans-serif`;
  ctx.fillText(startText.subtitle, canvas.width / 2 / (window.devicePixelRatio || 1), canvas.height / 2 / (window.devicePixelRatio || 1));

  ctx.font = `${18 * scaleFactor}px sans-serif`;
  ctx.fillText(startText.description, canvas.width / 2 / (window.devicePixelRatio || 1), canvas.height / 2 / (window.devicePixelRatio || 1) + 30 * scaleFactor);
}

// --- End game ---
function endGame(win){
    gameOver = true;

    // Dim background
    ctx.fillStyle = "rgba(0,0,0,0.6)";
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // Set text style
    ctx.fillStyle="white";
    ctx.textAlign="center";
    ctx.textBaseline = "middle";

    // Title message
    ctx.font = `bold ${28 * scaleFactor}px sans-serif`;
    ctx.fillText(win ? "üèÅ You made it!" : "üí• Curses! Foiled again",
                 canvas.width / 2, canvas.height / 2 - 20 * scaleFactor);

    // Subtitle message
    ctx.font = `${20 * scaleFactor}px sans-serif`;
    ctx.fillText("Press R or tap to restart",
                 canvas.width / 2, canvas.height / 2 + 20 * scaleFactor);

    if(win) setTimeout(()=>document.getElementById("clue").style.display="block", 1000);
}


// --- Controls ---
document.addEventListener("keydown",e=>{
    if(e.code==="Space"||e.code==="ArrowUp"){
        if(!started){ started=true; update(); }
        if(!gameOver) velocity=jump;
    }
    if(e.code==="KeyR" && gameOver) resetGame();
});

// --- Touch input ---
let touchActive = false;

document.addEventListener("touchstart", e => {
    // prevent default zoom/scroll
    e.preventDefault();

    if (touchActive) return;
    touchActive = true;

    if (!started) { started = true; update(); return; }
    if (gameOver) { resetGame(); return; }

    velocity = jump;
});

document.addEventListener("touchend", e => {
    touchActive = false;
});



// --- Responsive canvas ---
function resizeCanvas() {
  const aspect = 480 / 640;
  let w = window.innerWidth;
  let h = window.innerHeight;

  if (w / h > aspect) w = h * aspect;
  else h = w / aspect;

  canvas.style.width = w + "px";
  canvas.style.height = h + "px";

  const dpr = window.devicePixelRatio || 1;
  canvas.width = 480 * dpr;
  canvas.height = 640 * dpr;

  // Apply scale correctly
  ctx.setTransform(1, 0, 0, 1, 0, 0);
  ctx.scale(dpr, dpr);

  scaleFactor = canvas.width / 480 / dpr;

  // Now that scaling is correct, reset the game display
  resetGame();
}

window.addEventListener("resize",resizeCanvas);

// --- Init ---
carImg.onload = ()=>{
    buildBackground();
    resizeCanvas();
};
</script>
</body>
</html>
