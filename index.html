<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<title>Flappy Car</title>
<style>
  body {
    margin: 0;
    overflow: hidden;
    background: #9dd9ff;
  }
  #gameCanvas {
    display: block;
    margin: auto;
    background: #87ceeb;
  }
  #clue {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(255,255,255,0.9);
    padding: 20px 30px;
    border-radius: 15px;
    box-shadow: 0 0 10px rgba(0,0,0,0.3);
    font-size: 1.2em;
    text-align: center;
    display: none;
  }
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<div id="clue">üïµÔ∏è‚Äç‚ôÇÔ∏è Cestitke!!</div>
<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
const happyFace = new Image();
happyFace.src = "happyFace.png"; // Make sure this is high-res (2√ó or 3√ó)


// --- Images ---
const carImg = new Image();
carImg.src = "car.png";

// --- Game state ---
let carY, velocity, obstacles, frame, gameOver, started;
const gravity = 0.4;
const jump = -7;
let backgroundOffset = 0;
let timeOfDay = 0;
let distance = 0;
let scaleFactor = 1;
let winState = false;

// --- Background offscreen canvas ---
const bgWidth = 1920;
const bgHeight = 640;
const bgCanvas = document.createElement("canvas");
bgCanvas.width = bgWidth;
bgCanvas.height = bgHeight;
const bgCtx = bgCanvas.getContext("2d");

// --- Stars ---
const stars = [];
for (let i = 0; i < 80; i++) {
  stars.push({
    x: Math.random() * bgWidth,
    y: Math.random() * 320,
    size: Math.random() * 2 + 1
  });
}

// --- Obstacles track ---
const baseGapY = 250;
const horizontalSpacing = 300;
const offsets = [];
const segments = [
  [-80,-50,-30,-60,-40],
  [60,80,70,90],
  [-100,-90,-70],
  [0,100,-80,50],
  [40,-60,20,-50,30]
];
while (offsets.length < 100) segments.forEach(s => offsets.push(...s));
offsets.length = 100;
const track = offsets.map((o,i)=>({x:600+i*horizontalSpacing,gapY:baseGapY+o}));

// --- Utilities ---
function lerpColor(a,b,t){
  const ah=parseInt(a.replace('#',''),16),ar=(ah>>16)&0xff,ag=(ah>>8)&0xff,ab=ah&0xff;
  const bh=parseInt(b.replace('#',''),16),br=(bh>>16)&0xff,bg=(bh>>8)&0xff,bb=bh&0xff;
  const rr=Math.round(ar+(br-ar)*t),rg=Math.round(ag+(bg-ag)*t),rb=Math.round(ab+(bb-ab)*t);
  return `rgb(${rr},${rg},${rb})`;
}

// --- Build static background ---
function buildBackground() {
  const hillColors = ["#4caf50","#66bb6a","#81c784"];
  hillColors.forEach((color,i)=>{
    const amplitude = 40 + i*25;
    const offsetY = 100 - i*20;
    bgCtx.fillStyle = color;
    bgCtx.beginPath();
    bgCtx.moveTo(0,bgHeight);
    for(let x=0;x<=bgWidth;x+=20){
      const y = bgHeight - (amplitude * Math.sin((x+i*100)*0.004)) - offsetY;
      bgCtx.lineTo(x,y);
    }
    bgCtx.lineTo(bgWidth,bgHeight);
    bgCtx.closePath();
    bgCtx.fill();
  });

  // Clouds
  bgCtx.fillStyle="white";
  for(let i=0;i<20;i++){
    const x = Math.random()*bgWidth;
    const y = Math.random()*200+50;
    const size = Math.random()*40+20;
    bgCtx.beginPath();
    bgCtx.arc(x,y,size,0,Math.PI*2);
    bgCtx.arc(x+size*0.8,y+10,size*0.8,0,Math.PI*2);
    bgCtx.arc(x-size*0.8,y+10,size*0.8,0,Math.PI*2);
    bgCtx.fill();
  }
}

// --- Draw background ---
function drawBackground(speed=0){
  backgroundOffset += speed;
  const offsetX = backgroundOffset % bgWidth;

  timeOfDay = Math.min(1, Math.max(0,(distance-10000)/24000));
  const currentSky = lerpColor("#87ceeb","#00143d", timeOfDay);
  ctx.fillStyle = currentSky;
  ctx.fillRect(0,0,480,640);

  ctx.drawImage(bgCanvas,-offsetX,0,bgWidth*scaleFactor,bgHeight*scaleFactor);
  ctx.drawImage(bgCanvas,bgWidth-offsetX,0,bgWidth*scaleFactor,bgHeight*scaleFactor);

  const nightOverlay = `rgba(0,20,60,${timeOfDay*0.4})`;
  ctx.fillStyle = nightOverlay;
  ctx.fillRect(0,0,480,640);

  if(timeOfDay>0.4){
    ctx.fillStyle = `rgba(255,255,255,${0.4*Math.min((timeOfDay-0.4)*1.5,1)})`;
    for(const s of stars){
      const x = (s.x*scaleFactor-offsetX+bgWidth*scaleFactor)%(bgWidth*scaleFactor);
      const y = s.y*scaleFactor;
      ctx.beginPath();
      ctx.arc(x,y,s.size*scaleFactor,0,Math.PI*2);
      ctx.fill();
    }
  }
}

// --- Draw car ---
function drawCar(){
  const scale = 0.12*scaleFactor;
  const w = carImg.width*scale;
  const h = carImg.height*scale;
  const tilt = velocity*2*Math.PI/180;
  ctx.save();
  ctx.translate(100,carY);
  ctx.rotate(tilt);
  ctx.drawImage(carImg,-w/2,-h/2,w,h);
  ctx.restore();
}

// --- Draw obstacles ---
function drawObstacles(){
  const obsW = 60*scaleFactor;
  const obsGap = 100*scaleFactor;
  for(const o of obstacles){
    ctx.fillStyle="rgba(240,108,0,0.6)";
    ctx.strokeStyle="black";
    ctx.lineWidth=2*scaleFactor;
    ctx.beginPath();
    ctx.rect(o.x,0,obsW,o.gapY-obsGap);
    ctx.fill(); ctx.stroke();
    ctx.beginPath();
    ctx.rect(o.x,o.gapY+obsGap,obsW,640-o.gapY);
    ctx.fill(); ctx.stroke();
  }
}

// --- Game loop ---
let lastTime = 0;
function update(timestamp){
  if(gameOver) return;
  if(!lastTime) lastTime = timestamp;
  const delta = (timestamp-lastTime)/1000;
  lastTime = timestamp;

  velocity += gravity*delta*60;
  carY += velocity*delta*60;

  const speed = (3 + frame/800)*delta*60;
  obstacles.forEach(o=>o.x-=speed*scaleFactor);
  distance += speed;
  frame++;

  drawBackground(speed*scaleFactor);
  drawObstacles();
  drawCar();

  // Obstacle counter
  const obstaclesLeft = obstacles.filter(o => o.x > -60*scaleFactor).length;
  ctx.font = `bold ${40*scaleFactor}px sans-serif`;
  ctx.textAlign="center";
  ctx.textBaseline="top";
  ctx.lineWidth = 4*scaleFactor;
  ctx.strokeStyle = "white";
  ctx.strokeText(obstaclesLeft,240,80);
  ctx.fillStyle="black";
  ctx.fillText(obstaclesLeft,240,80);

  // Collisions
  const obsW = 60*scaleFactor;
  const obsGap = 100*scaleFactor;
  for(const o of obstacles){
    if(100-25<o.x+obsW && 100+25>o.x && (carY-10<o.gapY-obsGap || carY+10>o.gapY+obsGap))
      return endGame(false);
  }
  if(carY<0||carY>640) return endGame(false);
  if(obstacles.every(o=>o.x<-obsW)) return endGame(true);

  requestAnimationFrame(update);
}

// --- Reset & End game ---
const startText = {
  title:"üßô HP 3: The Chamber ü™Ñ V10",
  subtitle:"GCBF1BN, by Enra13 & Ammy Holmes",
  description:"Press SPACE or tap to start your flight!"
};

function drawWinImage() {
  const dpr = window.devicePixelRatio || 1;
  const canvasWidth = canvas.width / dpr;
  const canvasHeight = canvas.height / dpr;

  const imgAspect = happyFace.width / happyFace.height;
  const canvasAspect = canvasWidth / canvasHeight;

  let drawWidth, drawHeight, offsetX, offsetY;

  if (imgAspect > canvasAspect) {
    drawWidth = canvasWidth;
    drawHeight = canvasWidth / imgAspect;
    offsetX = 0;
    offsetY = (canvasHeight - drawHeight)/2;
  } else {
    drawHeight = canvasHeight;
    drawWidth = canvasHeight * imgAspect;
    offsetX = (canvasWidth - drawWidth)/2;
    offsetY = 0;
  }

  ctx.drawImage(happyFace, offsetX, offsetY, drawWidth, drawHeight);
}


function resetGame() {
  carY = 320;
  velocity = 0;
  frame = 0;
  backgroundOffset = 0;
  gameOver = false;
  started = false;
  distance = 0;
  lastTime = 0;
  obstacles = track.map(o => ({ ...o }));
  document.getElementById("clue").style.display = "none";

  // --- Dark dusk gradient background ---
  const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
  gradient.addColorStop(0, "#0b1f3f");
  gradient.addColorStop(0.5, "#1a3a6d");
  gradient.addColorStop(1, "#5c3b1e");
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // --- Text ---
  ctx.fillStyle = "white";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";

  const logicalWidth = 480;
  const logicalHeight = 640;
  const dpr = window.devicePixelRatio || 1;
  const scale = Math.min(
    (canvas.width / dpr) / logicalWidth,
    (canvas.height / dpr) / logicalHeight
  );

  const centerX = logicalWidth / 2;
  const startY = 220; // starting Y for title block

  // Title
  ctx.font = `bold ${32 * scale}px sans-serif`;
  ctx.fillText("üßô HP 3: The Chamber ü™Ñ V10", centerX, startY * scale);

  // Code below title (same size)
  ctx.fillText("GCBF1BN", centerX, (startY + 40) * scale);

  // Author (smaller)
  ctx.font = `${20 * scale}px sans-serif`;
  ctx.fillText("by Enra13 & Ammy Holmes", centerX, (startY + 80) * scale);

  // Description (smaller again)
  ctx.font = `${16 * scale}px sans-serif`;
  ctx.fillText("Press SPACE or tap to start your flight!", centerX, (startY + 120) * scale);
}





function endGame(win) {
  gameOver = true;
  winState = win;

  // Dim background
  ctx.fillStyle = "rgba(0,0,0,0.6)";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  if (win) {
    // Draw happyFace and keep it displayed
    if (happyFace.complete) {
      drawWinImage();
    } else {
      happyFace.onload = drawWinImage;
    }

    // Don't allow restart, clue is in the image itself
    document.getElementById("clue").style.display = "none"; 
  } else {
    // Losing text
    ctx.fillStyle = "white";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.font = `bold ${28 * scaleFactor}px sans-serif`;
    ctx.fillText("üí• Curses! Foiled again", 240, 300);
    ctx.font = `${20 * scaleFactor}px sans-serif`;
    ctx.fillText("Press R or tap to restart", 240, 340);
  }
}


// --- Controls ---
document.addEventListener("keydown", e => {
  if (e.code === "Space" || e.code === "ArrowUp") {
    if (!started) {
      started = true;
      requestAnimationFrame(update);
    } else if (!gameOver) {
      velocity = jump;
    }
  }
  if (e.code === "KeyR" && gameOver && !winState) {
    resetGame();
  }
});

// --- Touch input ---
document.addEventListener("touchstart", e => {
  e.preventDefault();
  if (!started) {
    started = true;
    requestAnimationFrame(update);
    return;
  }
  if (gameOver && !winState) {
    resetGame();
    return;
  }
  if (!gameOver) velocity = jump;
});


// --- Responsive canvas ---
function resizeCanvas(){
  const aspect=480/640;
  let w=window.innerWidth, h=window.innerHeight;
  if(w/h>aspect) w=h*aspect; else h=w/aspect;
  canvas.style.width=w+"px";
  canvas.style.height=h+"px";
  const dpr=window.devicePixelRatio||1;
  canvas.width=480*dpr;
  canvas.height=640*dpr;
  ctx.setTransform(1,0,0,1,0,0);
  ctx.scale(dpr,dpr);
  scaleFactor = canvas.width/480/dpr;
  resetGame();
}
window.addEventListener("resize",resizeCanvas);

// --- Init ---
carImg.onload = ()=>{
  buildBackground();
  resizeCanvas();
};
</script>
</body>
</html>
